{"version":3,"sources":["../src/getStateFromCookies.js"],"names":["pathSlicer","path","getSubtree","subtree","key","indexOf","remaining","split","slice","join","state","getStateFromCookies","preloadedState","paths","getCookie","Object","keys","forEach","pathConf","pathToState","pathSplit","terminalKey","storedState","name","stateTree","length","JSON","parse","err","console","error"],"mappings":";;;;;;AAAA;;AAEA;;;;;AAKA,SAASA,UAAT,CAAoBC,IAApB,EAA0B;AACtB,QAAMC,aAAa,SAAbA,UAAa,CAACC,OAAD,EAAUC,GAAV,EAAkB;AACjC,YAAIA,IAAIC,OAAJ,CAAY,GAAZ,IAAmB,CAAC,CAAxB,EAA2B;AACvB,gBAAMC,YAAYF,IAAIG,KAAJ,CAAU,GAAV,EAAeC,KAAf,CAAqB,CAArB,EAAwBC,IAAxB,CAA6B,GAA7B,CAAlB;;AAEA,mBAAOP,WAAWC,QAAQC,IAAIG,KAAJ,CAAU,GAAV,EAAe,CAAf,CAAR,CAAX,EAAuCD,SAAvC,CAAP;AACH;AACD,eAAOH,QAAQC,GAAR,CAAP;AACH,KAPD;;AASA,WAAO,UAACM,KAAD;AAAA,eAAWR,WAAWQ,KAAX,EAAkBT,IAAlB,CAAX;AAAA,KAAP;AACH;;AAED;;;;;;;AAOA,IAAMU,sBAAsB,SAAtBA,mBAAsB,CACxBC,cADwB,EAExBC,KAFwB,EAIvB;AAAA,QADDC,SACC;;AACDC,WAAOC,IAAP,CAAYH,KAAZ,EAAmBI,OAAnB,CAA2B,uBAAe;AACtC,YAAMC,WAAWL,MAAMM,WAAN,CAAjB;AACA,YAAMC,YAAYD,YAAYZ,KAAZ,CAAkB,GAAlB,CAAlB;AACA,YAAMc,cAAcD,UAAUZ,KAAV,CAAgB,CAAC,CAAjB,CAApB;;AAEA;AACA,YAAMc,cAAcR,UAAUI,SAASK,IAAnB,CAApB;;AAEA;AACA,YAAMC,YAAYJ,UAAUK,MAAV,GAAmB,CAAnB,GACdzB,WAAWoB,UAAUZ,KAAV,CAAgB,CAAhB,EAAmB,CAAC,CAApB,EAAuBC,IAAvB,CAA4B,GAA5B,CAAX,EAA6CG,cAA7C,CADc,GAEdA,cAFJ;;AAIA,YAAIU,WAAJ,EAAiB;AACb,gBAAI;AACAE,0BAAUH,WAAV,IAAyBK,KAAKC,KAAL,CAAWL,WAAX,CAAzB;AACH,aAFD,CAEE,OAAOM,GAAP,EAAY;AACVC,wBAAQC,KAAR,yCAAoDZ,SAASK,IAA7D,gBAA8EK,GAA9E;AACH;AACJ;AACJ,KApBD;;AAsBA,WAAOhB,cAAP;AACH,CA5BD;;kBA8BeD,mB","file":"getStateFromCookies.js","sourcesContent":["import { getCookie as getBrowserCookie } from './cookieApi';\n\n/**\n * return the node referenced by path in state.\n * @param {Object} path\n * @return {Object} node reference\n **/\nfunction pathSlicer(path) {\n    const getSubtree = (subtree, key) => {\n        if (key.indexOf('.') > -1) {\n            const remaining = key.split('.').slice(1).join('.');\n\n            return getSubtree(subtree[key.split('.')[0]], remaining);\n        }\n        return subtree[key];\n    };\n\n    return (state) => getSubtree(state, path);\n}\n\n/**\n * read browser cookie into state\n * @param {Object} preloaded state\n * @param {Object} paths\n * @param {Object} get Cookie implementation\n * @return {Object} new state\n **/\nconst getStateFromCookies = (\n    preloadedState,\n    paths,\n    getCookie = getBrowserCookie\n) => {\n    Object.keys(paths).forEach(pathToState => {\n        const pathConf = paths[pathToState];\n        const pathSplit = pathToState.split('.');\n        const terminalKey = pathSplit.slice(-1);\n\n        // read cookies\n        const storedState = getCookie(pathConf.name);\n\n        // get a slice of state path where to put cookie value\n        const stateTree = pathSplit.length > 1 ? (\n            pathSlicer(pathSplit.slice(0, -1).join('.'))(preloadedState)\n        ) : preloadedState;\n\n        if (storedState) {\n            try {\n                stateTree[terminalKey] = JSON.parse(storedState);\n            } catch (err) {\n                console.error(`Unable to set state from cookie at ${pathConf.name}. Error: `, err);\n            }\n        }\n    });\n\n    return preloadedState;\n};\n\nexport default getStateFromCookies;\n"]}